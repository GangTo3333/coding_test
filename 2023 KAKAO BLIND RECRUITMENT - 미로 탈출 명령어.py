# 2023 KAKAO BLIND RECRUITMENT - 미로 탈출 명령어

def solution(n, m, x, y, r, c, k):
    # 키 조작의 우선 순위가 d-l-r-u 이므로 (n * m) 의 격자 규격 내에서 d 와 l 방향으로 최대한 많이 이동.
    d = abs(n - x)
    l = abs(1 - y)

    # 이후 (n, 1) 위치에서 도착지점으로 이동.
    r = abs(1 - c)
    u = abs(n - r)

    # (n, 1)을 지나칠 때 최소 이동 거리 move. (n, 1)을 지나가는 경로가 사전 순으로 가장 앞에 위치함.
    move = d + l + r + u

    # 남은 이동 거리 혹은 부족한 이동 거리가 짝수가 아니면 도달할 수 없음.
    # (간 만큼 돌아오고, 덜 간 만큼 돌아가지 않아도 되기 때문 == 1의 진행이 필연적으로 2의 배수가 되는 구조.)
    if abs(move - k) % 2 != 0:
        return "impossible"

    # (n, 1)을 지나가는 경로(사전 순으로 가장 앞에 위치) 와 움직이는 횟수 k가 일치.
    if move == k:
        return 'd' * d + 'l' * l + 'r' * r + 'u' * u

    # (n, 1)을 지나가는 경로(사전 순으로 가장 앞에 위치) 가 움직이는 횟수 k보다 적으면 남은 횟수 만큼 'rl' 과 'ud'로 반복.
    elif move < k:
        k -= move
        if m != 1:
            return 'd' * d + 'l' * l + 'rl' * (k // 2) + 'r' * r + 'u' * u
        else:
            return 'd' * d + 'l' * l + 'r' * r + 'ud' * (k // 2) + 'u' * u

    # (n, 1)을 지나가는 경로(사전 순으로 가장 앞에 위치) 가 움직이는 횟수 k보다 많으면 (n, 1) 을 지나갈 수 없음.
    # 초과된 거리를 사전 기준 느린 순으로 1씩 제거.
    elif move > k:
        k = move - k

        while l and r and k:
            l -= 1
            r -= 1
            k -= 2

        while d and u and k:
            d -= 1
            u -= 1
            k -= 2

        # l 과 r, d 와 u 의 짝이 맞지 않아 k가 남는 경우: 최소 이동 거리보다 k가 적어 불가능.
        if k:
            return "impossible"
        else:
            return 'd' * d + 'l' * l + 'r' * r + 'u' * u

''' 모든 경로를 탐색하여 사전 순으로 정렬하는 순간 시간이 엄청 오래 걸리는 문제.

    만약 격자에 (n*m) 제한이 없었다면 start 와 end 의 최소 거리를 찾고,
    남은 이동 횟수만큼 'd' 와 'u' 를 앞 뒤로 붙이는, 마치 위와 비슷한 접근 방식을 누구나 쉽게 생각했을 것.
    
    격자의 제한이 적어 보인다고 DFS 로 접근하는 함정에 빠지지 않게, 항상 문제를 다양한 방법으로 구상해야 함.
    시간이 오래 걸리는 '브루트 포스' 알고리즘은 최후의 수단임.'''