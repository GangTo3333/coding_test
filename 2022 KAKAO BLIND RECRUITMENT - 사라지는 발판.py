# 2022 KAKAO BLIND RECRUITMENT - 사라지는 발판

# 발판이 존재하는 곳의 좌표와, 현재 위치의 좌표를 통해 상, 하, 좌, 우 중 갈 수 있는 곳을 return 하는 함수.
def go(can, start):
    x, y = start
    r, c = [0, 0, 1, -1], [1, -1, 0, 0]

    # 보드의 규격을 무시하고, 교집합을 사용하기 위해 set() 활용.
    way = set()
    for i in range(4):
        way.add((x + r[i], y + c[i]))

    return can & way

# 게임을 진행하여 결과를 도출하는 함수. 편의상 먼저 움직이는 플레이어를 A, 나머지를 B로 설명.
def game(can, aloc, bloc, cnt):

    # 현재까지 움직인 횟수가 0 또는 짝수일 경우 A의 차례. 플레이어 A가 기준이 됨.
    if cnt % 2 == 0:

        # A가 이동할 수 있는 위치.
        way = go(can, aloc)

    # 움직인 횟수가 홀수일 경우 B의 차례이므로 B가 이동할 수 있는 위치를 구함. 플레이어 B가 기준이 됨.
    elif cnt % 2 != 0:
        way = go(can, bloc)

    # 더이상 갈 수 있는 곳이 없는 경우: 현재 차례의 플레이어 패배.
    if not way:

        # 현재까지 움직인 횟수가 홀수일 경우 A의 승리: 1(True), 이동 횟수 반환.
        # 현재까지 움직인 횟수가 짝수일 경우 B의 승리: 0(False), 이동 횟수 반환.
        return cnt % 2, cnt

    # 갈 수 있는 곳이 있으나 A와 B가 같은 곳에 위치할 경우 현재 차례의 플레이어 승리.
    if aloc == bloc:

        # 이동 후 다음 상대의 패배에 의해 승리가 확정되는 형식.
        cnt += 1
        return cnt % 2, cnt

    # A 또는 B가 이겼을 때 이동 횟수, 졌을 때 이동 횟수를 담을 배열.
    win_route, lose_route = [], []

    # 플레이어 A의 차례일 경우.
    if cnt % 2 == 0:

        # A가 이동할 수 있는 위치를 하나씩 이동하면서 상대에게 차례를 넘김. 현재 위치는 이동 후 제거.
        for i in way:
            win, route = game(can - {aloc}, i, bloc, cnt + 1)

            # 끝까지 이동하여 결과가 나왔을 경우 이기면(True) win_route, 지면(False) lose_route 에 이동 횟수 삽입.
            if win:
                win_route.append(route)
            if not win:
                lose_route.append(route)

    # 플레이어 B의 차례일 경우.
    elif cnt % 2 != 0:
        for i in way:
            win, route = game(can - {bloc}, aloc, i, cnt + 1)

            # 끝까지 이동하여 결과가 나왔을 경우 이기면(False) win_route, 지면(True) lose_route 에 이동 횟수 삽입.
            if win:
                lose_route.append(route)
            if not win:
                win_route.append(route)

    # 현재 플레이어가 현재 루트에서 승리하는 경우가 존재할 시.
    if win_route:
        # A의 차례(cnt가 짝수)일 경우 A의 승리(True)를 반환해야하고 B의 차례일 경우 그 반대이므로 cnt에 + 1. 승리한 경기 중 가장 짧은 경기 횟수 반환.
        cnt += 1
        return cnt % 2, min(win_route)

    # 현재 플레이어가 승리하는 경우가 존재하지 않을 시.
    else:
        # 상대 플레이어의 승리와, 가장 늦게 지는 경우의 경기 횟수 반환.
        return cnt % 2, max(lose_route)


def solution(board, aloc, bloc):
    # list는 set의 원소로 사용 불가.
    aloc = tuple(aloc)
    bloc = tuple(bloc)

    # 발판이 있는 좌표 찾기.
    can = set()
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] == 1:
                can.add((i, j))

    win, cnt = game(can, aloc, bloc, 0)

    return cnt

''' 개인적으로 구현이 너무 복잡하고 어려웠던 문제.
    재귀함수를 사용하니 함수가 어떻게 작동하는지 확인하는 것도 쉽지 않았기에, return 값에 대한 확신이 있어야만 했음.
    
    재귀함수인 game() 함수의 마지막 if - else 문은 현재 상황에서 플레이어 A와 B가 가장 '최선의 수'를 두는 방식.
    만약 승리하는 방법이 있다면 가장 빠르게 승리할 수 있는 수를, 더이상 승리할 방법이 없다면 가장 늦게 패배하는 수를 return 한다.
    
    두 플레이어가 모두 실수를 하지 않고, 최선의 수를 둔다는 가정 하에 승자와 패자는 정해져있다는 것을 인지하는게 가장 중요함.
    
    만약 A의 승리일 경우, B가 승리하는 루트도 있을 수 있고, A가 더 빠르게 승리하는 루트 또한 분명히 있음.
    그러나 두 상황 모두 A 혹은 B의 '실수'에 의해 일어나는 일이고, 이는 game() 함수의 마지막 if - else 문에서 고려하지 않는다.
    
    A의 더 빠른 승리 루트는 B의 차례에서 더 빠른 패배 루트이며, B의 승리 루트는 A의 패배 루트이기에,
    더 좋은 수 (이길 수 있거나, 더 느리게 지는)가 있는 이상, 이미 한 단계 더 깊은 재귀함수에서 걸러지는 값들임.
    
    그렇게 '최선의 수'를 둔 경기가 끝이 났을 때의 승자와, 한 칸씩 무르면서(재귀함수의 바깥으로 이동하면서) 이동 횟수를 가려낸다.
    
    여담이지만, 문제를 해결하면서 문득 알파고가 이런 원리로 작동하는지 궁금하기도 했다.
    과연 바둑의 모든 수를 고성능의 프로그램으로 완전탐색하여 두는 것인지, 아니면 수많은 시뮬레이션을 통해 서로의 좌표에 따른 데이터를 저장하여
    가장 승률이 높은 값을 구사하는 건지,
    
    만약 전자일 경우 아무리 빠르게 탐색을 한다 해도, 고려하지 않아도 되는 수 (상대방의 실수)를 어떤 방식의 조건을 걸어 탐색을 효율적으로 하는지,
    후자일 경우 좋은 의미의 AI 학습이지만, 결국은 AI가 승리, 패배했던 수많은 경기 중 한 경기를 그대로 모방한 결과물일텐데 이를 지능이라 칭할 수 있는지...
    
    또한, 요즘 세상의 뜨거운 관심을 받는 챗 GPT와 AI그림의 결과물이 무분별한 학습과 단순 모방의 집합체라면 과연 저작권에 있어 자유로운 것이 맞는지,
    인간은 어떻게 같은 정보를 접해도 개개인의 주관을 통한 다양한 해석이 생기고, 이를 통해 새로운 것들을 창조하는지 등등
    무수한 질문들이 꼬리에 꼬리를 물고 쏟아졌다.
    
    재귀함수에 대한 개념이 탄탄하지 않았고, 많은 문제를 통한 연습이 된 것도 아니라 고생도 많았지만,
    문제의 실마리를 찾으며 흥미를 느꼈고, 이를 실제로 구현함에 있어 생각의 폭이 더 넓어짐.'''